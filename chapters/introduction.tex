\chapter{Introduction} % Main chapter title
\label{chp:introduction} 

%\todo{numbers!}

Modern online companies make broadly use of cloud computing infrastructures for 
carrying their business.
Among the public cloud providers, the most popular and technologically advanced 
are Amazon Web Services (AWS), Microsoft Azure (Azure), and Google Cloud 
Platform (GCP)~\citep{flexera_report}.
To have a glance about the turnover, the second quarter of 2020 showed a growth 
of $62$\% of Azure respect the same period in the 
previous year, with investments of $79.9$M USD, $78$M 
USD, and $76.7$M USD from Verizon, MSI Computer, and LG Electronics, 
respectively~\citep{azure_business}.
We can observer similar figures in Amazon AWS services, that declared $1$M of 
active users in 2020, with $18$M USD invested by Netflix in the same 
year~\citep{aws_business}.
Still in 2020, $786$ tech companies choose GCP for their 
businesses~\citep{google_business}.

The widespread of cloud computing technologies arose the attention of security
experts concerning the protections of third part 
infrastructures~\citep{ryan2011cloud,sun2014data}.
Check Point and McAffe surveyed the possible threats that could target
cloud services~\citep{checkpoint_cloud,mcaffee_cloud}.
Such problems reveal to be even more critical when considering that a huge part 
of could infrastructures (\ie the host machines) are out of the companies 
control.
In this scenario, leaving part of the control to the could provider means 
trusting that a list of issues are already addressed at vendor side (\eg Azure 
or AWS).
The source of risk are various, for instance, the cloud provider might suffer 
of insider threats, \eg a GCP employ, with access to physical machines, could 
record the network traffic, access to the user's data, or tamper with the 
virtual machines (VM) themselves~\citep{insider_threat}.
Even if we assume having a trusted provider, recent works showed that two VMs, 
sharing the same host, can exchange information solely relying on the CPU 
cache~\citep{maurice2017hello}. This means that that a VM can carry attacks 
toward other VMs on the same host.

Having a cloud infrastructure introduces security risks also for the final 
user. In fact, a remote client (\eg a smartphone) has no guarantees to 
communicate with the the correct software in the remote 
VM~\citep{beekman2016attestation}, \eg a malicious hypervisor may manipulate 
the physical pages and force a VM to load non-intended 
content~\citep{10.1145/3292006.3300022}.
Another source of insecurity comes from the stored data: passwords and critical 
information are saved in non-volatile devices (\ie hard-drives) that are under 
control of the cloud provider as well, thus inevitably leading to integrity and 
confidentiality issues.
In this scenario, classic cryptography solutions fail since the whole system 
might be compromised, \ie the cloud provider may control the cryptographic keys.
Even though one could adopt mitigation to obtain reasonable guarantees, such 
as the intended software is properly loaded (\ie using TPM to protect 
the boot phase -- \cite{tpm-isoosi}), the underline system is secure (\ie 
through strict contracts or dedicated hosts -- \cite{aws_dedicated_host}), and
the data are sealed properly (\ie using modern crptographic 
schemes -- \cite{gentry2009fully}).
These solutions are rarely used in practice because either expensive or non 
scalalbe. The former requires dedicated hosts that are far more expensive than 
standard solutions, moreover TPMs are not usually provided by cloud vendors. 
The latter involves heavy cryptographic schemes that are too slow for 
being vastly used in daily business~\citep{10.1145/2046660.2046682}.
%
In addition to all the aforementioned problems, one should also consider 
classic exploitation techniques that may alter the logic of a piece of software 
by targeting the perimeter of a system.
In this scenario, an adversary may target error-prone services exposed over the 
Internet, and take control of 
machine~\citep{van2012memory,10.1145/2810103.2813646}.
Finally infecting the system.

%\todo{possible solution: TEE. Give intuitive definition.}
For tackling the aforementioned challenges, a promises direction is 
represented by Trusted Execution Environments (TEE).
Intuitively, TEEs are sub-systems, whose functioning remembers virtual 
machines, that use hardware features to isolate their content against untrusted 
environments.
%\todo{Definition of TEE and usage. Properties, memory isolation, and remote 
%attestation.}
%\todo{History of TEEs, first definition, standard used, etc. During the 
%	description, stay "high level" and recall properties and differences. This 
%	should give a context.} 
The TEEs are controlled by the main CPU, that represents the primary source of 
trust, and enable a user to define \emph{trusted memory regions} in the main 
memory (RAM)~\citep{Sabt2015TrustedEE}.
Historically, the first formal definition of TEE has been proposed by OMTP, 
whose design was mainly focused on mobile platforms~\citep{omtp}.
OMTP defines a list of properties that a TEE should fulfill, among them, this 
thesis will trait the \emph{memory isolation} and the \emph{remote attestation}.
The main purpose of the \emph{memory isolation} is to shield code and data such 
that even a compromised machine cannot alter its integrity (and 
confidentiality).
In particular, the \emph{memory isolation} must prevent tampering from any 
sources at any privilege level, \eg it must avoid writing and reading 
operations from the operating system, the SMM code~\citep{yao2009system}, and 
DMA transfers~\citep{coke1998implementing}.
The \emph{remote attestation}, instead, guarantees that a third party (\eg a 
smartphone) can verify the integrity of a remote memory region (\eg on a 
server).
This ensures that a client is communicating with the intended portion of code 
and machine (usually represented by the CPU).
The combination of \emph{memory isolation} and \emph{remote attestation} leads 
to a new range of properties in the cloud environments, \ie a company 
can use the \emph{memory isolation} to protect critical piece of 
software and date from insiders, a compromised host, or even other VMs sharing 
the same resources.
In addition, the \emph{remote attestation} allows the establishment of 
end-to-end secure channels without the support of the OS, thus avoiding the 
leak of cryptographic materials.
In addition, the TEEs can use attestation to seal data on non-volatile storage 
(\ie encrypt and decrypt) such that nobody but the original \emph{trusted 
region} can retrieve the content. 
TEEs are peculiar technologies that differ from previous solutions, such as TPM 
ones. Specifically, TMPs require an external hardware (\ie the TPM module), 
while TEEs are embedded in the main CPU.
Moreover, TPMs do not provide memory isolation, can only store limited 
cryptographic material (\eg keys), and expose a limited number functionalities 
(\eg random number generation or cryptographic primitives).
On the contrary, TEEs are meant to contain general purpose software that might 
interact with the peripherals.
In chapter~\ref{chp:background}, we detail the TEE background.

From the first OMTP definition, many vendors proposed their own TEE technology 
on the market.
In 2012, Intel proposed  Trusted Execution Technology 
(TXT) to measure the software integrity~\citep{greene2012intel}.
In 2014, ARM introduced the TrustZone technology in new lines of CPU and 
controllers~\citep{arm-trustzone}. 
%TrustZone devices can bootstrap two parallel OSs: one called \emph{enriched} 
%OS, that should handle all the normal operations; and a second one called 
%\emph{trusted} OS, with the duty to containing critical applications.
More recently, AMD proposed Secure Encrypted Virtualization 
(SEV) that shields whole VMs from their host~\citep{amdsev}, likewise,
Apple proposed a similar technology for their smartphones~\citep{apple-enclave}.
Among the various technologies, one particularly attracted the attention of the 
cloud market: Intel Software Guard eXtensions (SGX).
Intel SGX was announced in 2013~\citep{rozas2013intel} and is currently adopted 
by many cloud providers, such as Azure~\citep{azure}, 
GCP~\citep{challita2018precise}, IBM~\citep{IBM}, and 
Alibaba~\citep{alibabasgx}.
This technology provides either a strong \emph{memory isolation} and a reliable 
\emph{remote attestation} that stand at the base of many businesses, such as 
Signal~\citep{signal}.
Due to the important growth of SGX in the recent years, and considering its 
adoption in the cloud computing market, this thesis will consider SGX as main 
TEE technology.

\section{Software Guard eXtensions Overview}

The architecture of Intel Software Guard eXtensions (SGX) is synthesized in 
Figure~\ref{fig:sgx-architecture}.
The main concept of SGX are the \emph{enclaves}: memory regions in user-space 
physically isolated from the rest of the system.
SGX achieves \emph{memory isolation} due to a set of extra controls in the 
Memory Management Unit (MMU) and at micro-code level.
SGX considers the content of the \emph{enclaves} as trusted, and refers to them 
as \emph{trusted regions}, while the rest of the system is considered 
potentially malicious and is called \emph{untrusted region}.
The booting of an enclave is handled at kernel-space (\ie through a driver) in 
combination with CPU extra checks that ensure the correct \emph{enclave} 
loading.
Once an \emph{enclave} is bootstrapped, a remote entity can perform a 
\emph{remote attestation} (SGX RA) to verify the \emph{enclave} integrity.
The \emph{enclaves} live only in user-space and cannot directly 
interact with the kernel (\ie they cannot invoke \texttt{sycalls}).
The interaction between \emph{enclaves} and OS is handed by development 
frameworks that organize the enclave code in \emph{secure} and \emph{outside 
functions}.
The former are contained in the \emph{enclave} and handle critical pieces of 
code and data, while the latter are in the \emph{untrusted region} and interact 
with the system (\eg writing files, network communication).
We provide further details of the SGX internals in 
Section~\ref{sec:software-guard-extension}.

\begin{figure}[t]
	\centering
	\includegraphics[width=0.7\textwidth]{fig_c1/sgx-architecture.pdf}
	\caption[SGX architecture.]{Simplified SGX architecture.}
	\label{fig:sgx-architecture}
\end{figure}

\section{Thesis Contribution}

%\textbf{MY THESIS OBJECTIVE:}
Regardless the security guarantees achieved by SGX, this technology still 
suffers of important limitations.
In this thesis, we argue we can further address the SGX limitations (and in 
general the TEE ones) through a shrewd software design without the need of 
changing the hardware specification.
Specifically, we identify four important areas to investigate, and for each of 
them we propose up to two contributions.
To sum up, the thesis will describe five contributions in total that will 
address four aspect of SGX. The whole thesis contribution is summarized on 
Figure~\ref{fig:contribution}.

In the following, we summarize the four areas covered and the relative 
contributions. Finally, we elaborate each point in a dedicated section.

\begin{itemize}
	\item \textbf{Enclaves Scalability Limitations.} SGX machines can allocate 
	only few mega bytes for \emph{enclaves} purposes, thus affecting the amount 
	of critical content that can be protected.
	We thus study new software designs that stretch the SGX properties over 
	vaster memory areas (Section~\ref{ssec:contribution1}).
	This is depicted by the symbol \circledr[1] in 
	Figure~\ref{fig:contribution}.
	
	\item \textbf{New Threats Led by Memory Isolation.} The \emph{memory 
	isolation} could be used as a nest for a new category of malware. We study 
	to which extent an adversary can exploit SGX to introduce new treats in a 
	system (Section~\ref{ssec:contribution2}).
	This is depicted by the symbol \circledr[2] in 
	Figure~\ref{fig:contribution}.
	
	\item \textbf{Remote Attestation Limitations.} The standard RA can only 
	guarantee that an \emph{enclave} has been loaded properly, but it does 
	not consider runtime properties that might leave room for new threats.\
	We thus study new RA schemes that cover these aspects 
	(Section~\ref{ssec:contribution3}).
	This is addressed with two contributions that are represented with the 
	symbols \circledr[3] and \circledr[4] in Figure~\ref{fig:contribution}.
	
	\item \textbf{Incident Response Limitations.} The introduction of 
	non-observable memory regions affects the incidents response in 
	case of intrusion. We thus study the limitation of current investigation 
	techniques in the context of SGX machines 
	(Section~\ref{ssec:contribution4}).
	This is depicted by the symbol \circledr[5] in 
	Figure~\ref{fig:contribution}.
\end{itemize}

\begin{figure}[t]
	\centering
	\includegraphics[width=\textwidth]{fig_c1/contribution.pdf}
	\caption[Thesis contribution.]{Thesis contribution.\todo{elaborate this 
	image and give a glance for each point.}}
	\label{fig:contribution}
\end{figure}

%\begin{figure}[t]
%	\centering
%	\includegraphics[width=\textwidth]{fig_c1/mind-map.pdf}
%	\caption[Mind-map.]{Mind-map (TO REMOVE LATER).}
%	\label{fig:mind-map}
%\end{figure}


\subsection{Enclaves Scalability Limitations}
\label{ssec:contribution1}

The \emph{memory isolation} of TEE modules is a strong protection against 
tampering attacks, which are commonly model as Man-At-The-End adversary (MATE).
In this scenario, the adversary may edit the binary code to alter the process 
logic~\citep{AKHUNZADA201544}, while the defender must guarantee that an 
adversary cannot change the software logic to some extent. 
TEE technologies, and in particular SGX, provide \emph{enclaves} 
that shield the software, thus avoiding MATE by design~\citep{costan2016intel}.
However, TEEs often have practical limitations, \eg software within an 
\emph{enclave} cannot directly interact with the hosting OS; and the enclave 
often has size limitations~\citep{baumann2015shielding}.
Previous works studied solutions that move part of the OS functionality inside 
a \emph{trusted 
region}~\citep{baumann2015shielding,arnautov2016scone,tsai2017graphene},
but they introduce further complexity for employing a secure interaction with 
the rest of the world (\eg networking, file system).
Other authors suggested protecting only portions of the 
code~\cite{schuster2015vc3,lind2017glamdring}.
However, these approaches do not address critical limitations such as the 
interaction with the underlying OS, or the limited amount of memory.
Limited memory makes it unsustainable to deploy all processes in dedicated 
trusted containers.
For instance, machines featured with SGX provide only a few hundred megabytes 
that must be shared among all the running \emph{enclaves}.
If we consider processes such as Skype or Firefox, which require around 
$100$MB each, we need multiple \emph{enclaves} for each process to protect.
Therefore, this approach does not scale for multiple parallel processes.
The introduction of SGX $2.0$ allows modifying the size of a single trusted 
container but it does not modify the maximum memory available for trusted 
containers.

As an alternative approach, researchers proposed anti-tampering techniques, 
that allow a software to inspect itself and check whether its code has been 
modified.
We refer to those techniques as \emph{self-checking}, which literally read the 
binary code of the protected software by using special functions called 
\emph{checkers}.
The checkers compute a digital fingerprint of the software bytecode and verify 
whether that fingerprint matches a pre-computed 
value~\citep{nagra2009surreptitious}. 
However, purely software-based anti-tampering techniques are not 
completely secure, since the defending mechanisms reside in an 
\emph{untrusted memory region} and a determined attacker can identify and 
disarm such defenses.
It is possible to harden anti-tampering techniques by using a combination of 
additional 
approaches that raise the bar for the attackers but that do not fundamentally 
address the 
problem~~\citep{horne2001dynamic,banescu2017tutorial,chen2016advanced,chang2001protecting,viticchie2016reactive}

Considering all the aforementioned problems, we propose to combine the 
anti-tampering techniques and the SGX isolation to extend code protection over 
\emph{untrusted region}.
Finally overcoming the intrinsic limitations of SGX.
We detail our contribution in Chapter~\ref{chp:static-protection}.

\subsection{New Threats Led by Memory Isolation}
\label{ssec:contribution2}

Then addressed in (Chapter~\ref{chp:advanced-threats}).

\subsection{Remote Attestation Limitations}
\label{ssec:contribution3}

Then addressed in Chapter~\ref{chp:runtime-protection-untrusted} and
Chapter~\ref{chp:runtime-protection-trusted}.

\subsection{Incident Response Limitations}
\label{ssec:contribution4}

Then addressed in Chapter~\ref{chp:forensic}.

